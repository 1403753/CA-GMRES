/*
 * arnoldi_ca.cpp
 *
 *  Created on: 11.05.2018
 *      Author: Robert
 */

#include "arnoldi_ca.hpp"

arnoldi_ca::arnoldi_ca() {
	// Constructor
	
}

std::complex<double> prod(std::vector<std::complex<double>> *theta,
													std::vector<size_t> *mults, 
													std::vector<size_t> *outlist, size_t L1, size_t L2) {
	std::complex<double> prod = 1;
	for(size_t j = 0; j < L1; ++j) {
		prod *= std::pow(std::abs(theta->at(L1) - theta->at(j)), (double) mults->at(outlist->at(j)) / L2);
	}
	 
	 return prod;
}

void arnoldi_ca::print() {
	
	float rtime, ptime, mflops;
	long long flpops;
	float irtime, iptime, imflops;
  long long iflpops;
	
	std::cout.precision(20);
	
	/*
	*
	*	compute ritz values used in arnoldi(s)
	*
	*/
	
	gsl_rng *rng = gsl_rng_alloc(gsl_rng_taus2);
  gsl_rng_set(rng, time(NULL));

	const MKL_INT n = 12;
	
	
	
	MKL_INT alpha = 1;
	const char job = 'E';
	const char compz = 'N';
	double *H, *wr, *wi;
	wr = (double *)mkl_malloc(n*sizeof(double), 64);
	wi = (double *)mkl_malloc(n*sizeof(double), 64);

//	double wr[n] = {0.3795668652, 0.3795668652, -0.3795668652, -0.3795668652, -1, 0.3414450976, -0.3795668652, -0.3795668652, -1, .01, 0};
//	double wi[n] = {0.7694800092, -0.7694800092, 0.7694800092, -0.7694800092, 0, 0, 0.7694800092, -0.7694800092, 0, 0, 0};




	H = (double *)mkl_calloc(n*n, sizeof(double), 64);

	for(MKL_INT i = 0; i < n; ++i) 
		for(MKL_INT j = i; j < n; ++j) {
			H[i*n + j] = gsl_rng_uniform_int(rng, 100) + gsl_rng_uniform(rng);
			if(i + 1 < n)
				H[(i + 1)*n + j] = gsl_rng_uniform_int(rng, 100) + gsl_rng_uniform(rng);
		}
	/*
	for(MKL_INT i = 0; i < n; ++i) {
		for(MKL_INT j = 0; j < n; ++j)
			std::cout << H[i*n + j] << ' ';
		std::cout << std::endl;
	}
	*/
	

	/*
	*	compute ritz values of H
	*/
//LAPACKE_dhseqr(int matrix_layout, char job, char compz, lapack_int n, lapack_int ilo, lapack_int ihi, double *h, lapack_int ldh, double *wr, double *wi, double *z, lapack_int ldz);
	LAPACKE_dhseqr(LAPACK_ROW_MAJOR, job, compz, n, alpha, n, H, n, wr, wi, nullptr, n);
		
	std::vector<std::complex<double>>	ritz_vals;	
	std::vector<size_t>	mults(n, 1);

//	ritz_vals.reserve(sizeof(wr) / sizeof(wr[0]));
	ritz_vals.reserve(n);
	mults.reserve(ritz_vals.size());

	for(size_t i = 0; i < n; ++i) {
		ritz_vals.push_back( std::complex<double>(wr[i], wi[i]) );
	}
		
	std::stable_sort(ritz_vals.begin( ), ritz_vals.end( ), [ ]( const std::complex<double>& lhs, const std::complex<double>& rhs ) {
			return lhs.real() < rhs.real();
	});
	
	if(n < 12) {
		std::cout << "ritz sorted:\n";
		int k = 0;
		for(auto r: ritz_vals) {
			std::cout << r << '\n';
			if(std::imag(r) != 0) {
				if(k++ % 2 && std::imag(r) > 0) {
					std::cout << "ERRORRRRR!\n";
				}
			}
		}
	}
	for(size_t i = 0; i < ritz_vals.size() - 1;) {
		if(ritz_vals.at(i).imag() > 0) {
			if(i + 3 < ritz_vals.size() && ritz_vals.at(i) == ritz_vals.at(i + 2) && ritz_vals.at(i + 1) == ritz_vals.at(i + 3)) {
				ritz_vals.erase(ritz_vals.begin() + i);
				ritz_vals.erase(ritz_vals.begin() + i);
				mults.at(i)++;
				mults.at(i + 1)++;
			} else {
				i += 2;
			}
		} else {
			if(ritz_vals.at(i) == ritz_vals.at(i + 1)) {
				ritz_vals.erase(ritz_vals.begin() + i);
				mults.at(i)++;
			} else {
				i++;
			}
		}
	}
		
	ritz_vals.shrink_to_fit();
	mults.resize(ritz_vals.size());

//	std::cout << "sizes: " << ritz_vals.size() << ", " << mults.size() << std::endl;
	if(n < 12) {
		std::cout << "ritz:\n";
		int k = 0;
		for(auto r: ritz_vals) {
			std::cout << r << '\n';
			if(std::imag(r) != 0) {
				if(k++ % 2 && std::imag(r) > 0) {
					std::cout << "ERRORRRRR!\n";
				}
			}
		}
		
		std::cout << "mults:\n";
		for(auto r: mults) {
			std::cout << r << '\n';
		}
		
		std::cout << "_______________\n";
	}
	
	std::cout << "mults:\n";
	for(auto r: mults) {
		if (r > 1)
			std::cout << r << '\n';
	}
	
	/*
	*
	* Modified Leja ordering 
	*
	* TODO: check if z_k can be ommited instead of doing Algo 40 line 16: 
	*	k in {1,...,n} \outlist
	*
	*/
	
	std::complex<double> C_help, C = 1;
	size_t L;
	std::vector<std::complex<double>> theta;
	std::vector<size_t> outlist;
	
	
	
	if (ritz_vals.end()[-1].imag() == 0) {
		outlist.push_back(ritz_vals.size() - 1);
		theta.push_back(ritz_vals.end()[-1]);
		L = 0;
	} else {
		if (ritz_vals.end()[-2].imag() < 0)
			exit(-1);
		theta.push_back(ritz_vals.end()[-2]);
		theta.push_back(ritz_vals.end()[-1]);
		outlist.push_back(ritz_vals.size() - 2);
		outlist.push_back(ritz_vals.size() - 1);
		L = 1;
	}
	
	std::cout << "theta: " << theta.at(0) << std::endl;
	
	while(L < 1){//ritz_vals.size() - 1) {
		C_help = C;
		C = 1;
		
		C = prod(&theta, &mults, &outlist, L, L);
		
		for (auto &r: ritz_vals) {
			r /= (C / C_help);
		}
		
		for (auto &t: theta)
			t /= (C / C_help);

		
		std::cout << "ritzzz:\n";
		int b = 0;
		for(auto r: ritz_vals) {
			std::cout << r << '\n';
			if(std::imag(r) != 0) {
				if(b++ % 2 && std::imag(r) > 0) {
					std::cout << "ERRORRRRR!\n";
				}
			}
		}
		
		std::vector<std::complex<double>> zprod;
		
		for (size_t j = 0; j < L; ++j) {
			zprod.push_back(prod(&theta, &mults, &outlist, j, 1));
		}
		
		/*
		if (ritz_vals.end()[-1].imag() == 0) {
			theta.at(0) = ritz_vals.end()[-1];
			L = 0;
		} else {
			if (ritz_vals.end()[-2].imag() < 0)
				exit(-1);
			theta.at(0) = ritz_vals.end()[-2];
			theta.at(1) = ritz_vals.end()[-1];
			L = 1;
		}
		*/	
		L++;
	}
	
	
	/*
	*
	* Apply MODIFIED GIVENS ROTATION to H (used in CA-GMRES)
	*
	*/
	
	
	
	
	
	
	// re-initialize H	
	for(MKL_INT i = 0; i < n; ++i) 
		for(MKL_INT j = 0; j < n; ++j) {
			if(j < i-1)
				H[i*n + j] = 0;
			else
				H[i*n + j] = gsl_rng_uniform_int(rng, 100) + gsl_rng_uniform(rng);
		}
	
	if(n < 12) {
		std::cout << std::endl << "H:\n";

		for (int i = 0; i < n; ++i) {
			for (int j = 0; j < n; ++j)
				std::cout << H[n*i + j] << "\t";
			std::cout << std::endl;
		}
	}	
	
	double c = 0;
	double s = 0;
	double a = 0;
	double b = 0;
	
	if (PAPI_flops(&irtime, &iptime, &iflpops, &imflops) != PAPI_OK)
		exit(1);
	
	for (int i = 0; i < n - 1; ++i) {
			a = H[i*n + i];
			b = H[(i + 1)*n + i];
// void cblas_drotg (double *a, double *b, double *c, double *s);
			cblas_drotg(&a, &b, &c, &s);

// void cblas_drot (const MKL_INT n, double *x, const MKL_INT incx, double *y, const MKL_INT incy, const double c, const double s);
			cblas_drot(n - i, &H[i*n + i], 1, &H[(i + 1)*n + i], 1, c, s);
	}
	
	if (PAPI_flops(&rtime, &ptime, &flpops, &mflops) != PAPI_OK)
		exit(1);
	
	PAPI_shutdown();
	std::cout << n << ", " << rtime << std::endl;	
	
	if(n < 12) {
		std::cout << std::endl << std::endl << "H:\n";

		for (int i = 0; i < n; ++i) {
			for (int j = 0; j < n; ++j)
				std::cout << H[n*i + j] << "\t";
			std::cout << std::endl;
		}
	}
	
	
	
	
	// re-initialize H	
	for(MKL_INT i = 0; i < n; ++i) 
		for(MKL_INT j = 0; j < n; ++j) {
			if(j < i-1)
				H[i*n + j] = 0;
			else
				H[i*n + j] = gsl_rng_uniform_int(rng, 100) + gsl_rng_uniform(rng);
		}
	
	if(n < 12) {
		std::cout << std::endl << "H:\n";

		for (int i = 0; i < n; ++i) {
			for (int j = 0; j < n; ++j)
				std::cout << H[n*i + j] << "\t";
			std::cout << std::endl;
		}
	}
	
	double d1 = INT32_MAX;
	double d2 = INT32_MAX;
	double x1 = 0;
	double y1 = 0;
	double param[5]{};
	
	if (PAPI_flops(&irtime, &iptime, &iflpops, &imflops) != PAPI_OK)
			exit(1);
		
	for (int i = 0; i < n - 1; ++i) {
		//std::cout << std::endl << "d1: " << d1 << ", d2: "<< d2;
		x1 = H[i*n + i];
		y1 = H[(i + 1)*n + i];
//	void cblas_drotmg (double *d1, double *d2, double *x1, const double y1, double *param);
		cblas_drotmg (&d1, &d2, &x1, y1, param);
	
//	void cblas_drotm (const MKL_INT n, double *x, const MKL_INT incx, double *y, const MKL_INT incy, const double *param);
		cblas_drotm (n - i, &H[i*n + i], 1, &H[(i + 1)*n + i], 1, param);

	}
	
	if (PAPI_flops(&rtime, &ptime, &flpops, &mflops) != PAPI_OK)
		exit(1);
	
	PAPI_shutdown();
	std::cout << n << ", " << rtime << std::endl;	
	
	if(n < 12) {
		std::cout << std::endl << std::endl << "H:\n";

		for (int i = 0; i < n; ++i) {
			for (int j = 0; j < n; ++j)
				std::cout << H[n*i + j] << "\t";
			std::cout << std::endl;
		}
	}
	
	std::cout << std::endl << "d1: " << d1 << ", d2: "<< d2 <<  std::endl << std::endl;
	std::cout << "param: ";
	for (int j = 0; j < 5; ++j)
		std::cout << param[j] << ' ';
	
	std::cout << std::endl << std::endl;	
	
	
	
	
	
	
	mkl_free(H);
	mkl_free(wr);
	mkl_free(wi);
	gsl_rng_free(rng);
	mkl_free_buffers();
}

arnoldi_ca::~arnoldi_ca() {
	// Destructor
	
}



	/* NOT NEEDED!!
	HAD TO ITERATE OVER RITZ VALUES AND SWAP COMPLEX NUMBERS BECAUSE SORTING ALGO
	WAS UNSTABLE. REPLACEMENT WITH STABLE VERSION MADE THIS CODE OBSOLETE.
	
	for (int i = 0; i < n; ++i)
		if(std::imag(ritz_vals.at(i)) != 0) {
			if(std::imag(ritz_vals.at(i)) < 0) {
				std::swap(ritz_vals[i], ritz_vals[i + 1]);
				++i;
			} else ++i;
			
			if (std::real(ritz_vals.at(i-1)) != std::real(ritz_vals.at(i))) {
				std::cout << "error!\n";	
				exit(-1);
			}
		}
	std::cout << "ritz:\n";
	for(auto r: ritz_vals)
		std::cout << r << "\n";
	
	
	NOT NEEDED!!
	NORMAL GIVENS ROTATION (Valgrind error) AND MODIFIED GIVENS ROTATION EXAMPLES WITH 3X3 MATRICES
	
	{
		const int m = 3;
		double vec[m*m] = {9,0,2,
											 0,7,3,
											 2,3,1};
		double c = 0;
		double s = 0;
		double a = vec[0];
		double b = vec[m*2];

		for (int j = 0; j < m - 1; ++j) {
			for (int i = m; --i > j;) {
				a = vec[j*m + j];
				b = vec[i*m + j];
// void cblas_drotg (double *a, double *b, double *c, double *s);
				cblas_drotg(&a, &b, &c, &s);

// void cblas_drot (const MKL_INT n, double *x, const MKL_INT incx, double *y, const MKL_INT incy, const double c, const double s);
				cblas_drot(m - j, &vec[j*m + j], 1, &vec[i*m + j], 1, c, s);
			}
		}
		
		for (int i = 0; i < m; ++i) {
			for (int j = 0; j < m; ++j)
				std::cout << vec[m*i + j] << ' ';
			std::cout << std::endl;
		}
	
		std::cout << std::endl << "c: " << c << ", s: "<< s <<  std::endl << std::endl;
		double vec2[m*m] = {9,3,2,
												2,7,3,
												0,3,1};
		double d1 = 1;
		double d2 = 1;
		double x1;
		double param[5]{};
		
		for (int i = 0; i < m - 1; ++i) {
			x1 = vec2[i*m + i];
//	void cblas_drotmg (double *d1, double *d2, double *x1, const double y1, double *param);
			cblas_drotmg (&d1, &d2, &x1, vec2[(i + 1)*m + i], param);
	
//	void cblas_drotm (const MKL_INT n, double *x, const MKL_INT incx, double *y, const MKL_INT incy, const double *param);
			cblas_drotm (m - i, &vec2[i*m + i], 1, &vec2[(i + 1)*m + i], 1, param);
		}
	
		for (int i = 0; i < m; ++i) {
			for (int j = 0; j < m; ++j)
				std::cout << vec2[m*i + j] << ' ';
			std::cout << std::endl;
		}
	
		std::cout << std::endl << "d1: " << d1 << ", d2: "<< d2 <<  std::endl << std::endl;
		std::cout << "param: ";
		for (int j = 0; j < 5; ++j)
			std::cout << param[j] << ' ';
		
		std::cout << std::endl;
	}
	*/